# Просмотр дисков в Ubuntu

В Ubuntu (и других дистрибутивах Linux) есть несколько способов посмотреть список дисков и разделов. Вот несколько популярных методов:

## 1. Использование команды `lsblk`

Команда `lsblk` (list block devices) показывает информацию о всех блоковых устройствах, включая диски и разделы.

```bash
lsblk
```

### Пример вывода:

``` lsblk

NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
loop0    7:0    0    64M  1 loop /snap/core20/2379
loop1    7:1    0  55,6M  1 loop /snap/core18/2679
loop2    7:2    0 349,7M  1 loop /snap/gnome-3-38-2004/143
loop3    7:3    0  63,3M  1 loop /snap/core20/1778
loop4    7:4    0 239,1M  1 loop /snap/firefox/2311
loop5    7:5    0 157,8M  1 loop /snap/freemind/4
loop6    7:6    0 191,2M  1 loop /snap/postman/233
loop7    7:7    0 346,3M  1 loop /snap/gnome-3-38-2004/119
loop8    7:8    0  81,3M  1 loop /snap/gtk-common-themes/1534
loop10   7:10   0  91,7M  1 loop /snap/gtk-common-themes/1535
loop11   7:11   0 188,3M  1 loop /snap/postman/184
loop12   7:12   0     4K  1 loop /snap/bare/5
loop13   7:13   0 176,9M  1 loop /snap/firefox/1810
loop14   7:14   0 140,8M  1 loop /snap/projectlibre/5
loop15   7:15   0  45,9M  1 loop /snap/snap-store/592
loop16   7:16   0  49,8M  1 loop /snap/snapd/17950
loop17   7:17   0   284K  1 loop /snap/snapd-desktop-integration/14
loop18   7:18   0  45,9M  1 loop /snap/snap-store/638
loop19   7:19   0   304K  1 loop /snap/snapd-desktop-integration/49
loop20   7:20   0  38,8M  1 loop /snap/snapd/21759
loop21   7:21   0  55,7M  1 loop /snap/core18/2829
sda      8:0    0   100G  0 disk 
├─sda1   8:1    0     1M  0 part 
├─sda2   8:2    0   513M  0 part /boot/efi
└─sda3   8:3    0  99,5G  0 part /var/snap/firefox/common/host-hunspell
                                 /
sr0     11:0    1  1024M  0 rom 
```

## 2. Использование команды `fdisk`

Команда `fdisk` (format disk) может быть использована для просмотра информации о дисках и разделах.

```bash
sudo fdisk -l
```

### Пример вывода:

```
$ sudo fdisk -l
[sudo] пароль для user: 
Диск /dev/loop0: 63,97 MiB, 67080192 байт, 131016 секторов
Единицы: секторов по 1 * 512 = 512 байт
Размер сектора (логический/физический): 512 байт / 512 байт
Размер I/O (минимальный/оптимальный): 512 байт / 512 байт


Диск /dev/loop1: 55,61 MiB, 58310656 байт, 113888 секторов
Единицы: секторов по 1 * 512 = 512 байт
Размер сектора (логический/физический): 512 байт / 512 байт
Размер I/O (минимальный/оптимальный): 512 байт / 512 байт


Диск /dev/loop2: 349,7 MiB, 366682112 байт, 716176 секторов
Единицы: секторов по 1 * 512 = 512 байт
Размер сектора (логический/физический): 512 байт / 512 байт
Размер I/O (минимальный/оптимальный): 512 байт / 512 байт


Диск /dev/loop3: 63,27 MiB, 66347008 байт, 129584 секторов
Единицы: секторов по 1 * 512 = 512 байт
Размер сектора (логический/физический): 512 байт / 512 байт
Размер I/O (минимальный/оптимальный): 512 байт / 512 байт
...
```

## 3. Использование команды `df`

Команда `df` (disk filesystem) показывает информацию о файловых системах и их использовании.

```bash
df -h
```

### Пример вывода:

```
$ df -h
Файл.система   Размер Использовано  Дост Использовано% Cмонтировано в
tmpfs            792M         3,8M  788M            1% /run
/dev/sda3         98G          34G   60G           36% /
tmpfs            3,9G         112M  3,8G            3% /dev/shm
tmpfs            5,0M            0  5,0M            0% /run/lock
tmpfs            3,9G            0  3,9G            0% /run/qemu
/dev/sda2        512M         6,1M  506M            2% /boot/efi
```

## 4. Использование команды `blkid`

Команда `blkid` показывает информацию о блоковых устройствах, включая UUID и типы файловых систем.

```bash
sudo blkid
```

### Пример вывода:

```
$ sudo blkid
/dev/sda3: UUID="2ba55abf-86b2-4529-84a4-7b5209f0d168" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="c0ae4140-8cfe-4c9f-b551-5f30c7da0918"
/dev/loop1: TYPE="squashfs"
/dev/loop19: TYPE="squashfs"
/dev/loop17: TYPE="squashfs"
/dev/loop8: TYPE="squashfs"
/dev/loop15: TYPE="squashfs"
/dev/loop6: TYPE="squashfs"
/dev/loop13: TYPE="squashfs"
/dev/loop4: TYPE="squashfs"
/dev/loop21: TYPE="squashfs"
/dev/loop11: TYPE="squashfs"
/dev/loop2: TYPE="squashfs"
/dev/loop0: TYPE="squashfs"
/dev/loop18: TYPE="squashfs"
/dev/loop16: TYPE="squashfs"
/dev/loop7: TYPE="squashfs"
/dev/sda2: UUID="9722-12EE" BLOCK_SIZE="512" TYPE="vfat" PARTLABEL="EFI System Partition" PARTUUID="a4e4791e-b0e1-4a87-b8f6-6097e6f57b08"
/dev/loop14: TYPE="squashfs"
/dev/loop5: TYPE="squashfs"
/dev/loop12: TYPE="squashfs"
/dev/loop3: TYPE="squashfs"
/dev/loop20: TYPE="squashfs"
/dev/loop10: TYPE="squashfs"
/dev/sda1: PARTUUID="6d6fce1d-1d4d-4d63-8a9d-68a41fd05fc3"
```

## 5. Использование команды `parted`

Команда `parted` (partition editor) может быть использована для просмотра информации о разделах.

```bash
sudo parted -l
```

### Пример вывода:

```
$ sudo parted -l
Модель: VMware, VMware Virtual S (scsi)
Диск /dev/sda: 107GB
Размер сектора (логич./физич.): 512B/512B
Таблица разделов: gpt
Флаги диска: 

Номер  Начало  Конец   Размер  Файловая система  Имя                   Флаги
 1     1049kB  2097kB  1049kB                                          bios_grub
 2     2097kB  540MB   538MB   fat32             EFI System Partition  загрузочный, esp
 3     540MB   107GB   107GB   ext4
```

## 6. Использование команды `ls -l /dev/disk/by-id`

Эта команда показывает символические ссылки на блоковые устройства, что может быть полезно для идентификации дисков.

```bash
ls -l /dev/disk/by-id
```

### Пример вывода:

```
$ ls -l /dev/disk/by-id
итого 0
lrwxrwxrwx 1 root root 9 сен 30 23:35 ata-VMware_Virtual_SATA_CDRW_Drive_01000000000000000001 -> ../../sr0
```

# Практическое занятие 1

## 1. Использование команды `dd`

```bash
dd if=/dev/zero of=/tmp/disk.img bs=1M count=100
```

Команда dd if=/dev/zero of=/tmp/disk.img bs=1M count=100 используется для создания файла, заполненного нулями.

`dd`: Это утилита Unix, которая копирует и преобразует данные.

`if=/dev/zero`: Указывает входной файл. 

`/dev/zero` — это специальный файл, который возвращает столько нулевых байтов, сколько запрошено.

`of=/tmp/disk.img`: Указывает выходной файл. В данном случае, это файл /tmp/disk.img.

`bs=1M`: Устанавливает размер блока для копирования. 1M означает 1 мегабайт.

`ount=100`: Указывает количество блоков, которые нужно скопировать. В данном случае, это 100 блоков по 1 мегабайту каждый.

Таким образом, команда создает файл `/tmp/disk.img` размером `100` мегабайт, заполненный нулями. Этот файл может быть использован, например, для `создания виртуального диска` или для других `целей, требующих файла фиксированного размера, заполненного нулями`.

## 2. Использование команды `ls`

```bash
ls -lah /tmp/disk.img
```

Команда `ls -lah /tmp/disk.img` используется для отображения подробной информации о файле `/tmp/disk.img`

Рассмотрим команду подробнее:

`ls`: Это команда Unix, которая используется для отображения содержимого каталогов и информации о файлах.

`-l`: Этот флаг указывает ls выводить информацию в длинном формате, который включает права доступа, количество ссылок, владельца, группу, размер файла, дату последнего изменения и имя файла.

`-a`: Этот флаг указывает ls отображать все файлы, включая скрытые (те, что начинаются с точки).

`-h`: Этот флаг указывает ls выводить размеры файлов в удобочитаемом формате (например, в килобайтах, мегабайтах и т.д.).

Таким образом, команда `ls -lah /tmp/disk.img` выводит подробную информацию о файле `/tmp/disk.img`, включая его размер в удобочитаемом формате. 

Пример вывода может выглядеть так:

```$ ls -lah /tmp/disk.img
-rw-rw-r-- 1 user user 100M окт  1 00:35 /tmp/disk.img
```
Где:

`-rw-r--r--:` Права доступа к файлу.

`1`: Количество ссылок на файл.

`user:` Владелец файла.

`group`: Группа, к которой принадлежит файл.

`100M`: Размер файла в мегабайтах.

`Jan  1 12:34`: Дата и время последнего изменения файла.

`/tmp/disk.img`: Имя файла.

## 3. Использование команды `hexdump`

```bash
hexdump -C /tmp/disk.img
```

Команда `hexdump -C /tmp/disk.img` используется для отображения содержимого файла `/tmp/disk.img` в шестнадцатеричном формате. Давайте разберем её по частям:

`hexdump`: Это утилита Unix, которая используется для отображения содержимого файлов в шестнадцатеричном формате.

`-C`: Этот флаг указывает hexdump использовать формат вывода "canonical", который включает шестнадцатеричные значения байтов и соответствующие им символы ASCII (если они печатные).

Таким образом, команда `hexdump -C /tmp/disk.img` выводит содержимое файла `/tmp/disk.img` в шестнадцатеричном формате, где каждый байт файла отображается как шестнадцатеричное значение, а также соответствующий символ ASCII (если он печатный).

Пример вывода может выглядеть так:

```
$ hexdump -C /tmp/disk.img 
00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
06400000
```

Где:

`00000000`: Это смещение в файле (в шестнадцатеричном формате), указывающее начало файла.

`00 00 00 00 00 00 00 00 ...`: Шестнадцатеричные значения байтов. В данном случае, все байты равны нулю.

`|................|`: Соответствующие символы ASCII. В данном случае, все символы непечатные, так как все байты равны нулю.

`*`: Этот символ указывает, что следующие строки содержат те же данные, что и предыдущая строка. Это сокращение используется для уменьшения объема вывода, когда данные повторяются.

`06400000`: Это смещение в файле (в шестнадцатеричном формате), указывающее конец повторяющихся данных. В данном случае, это смещение указывает на конец файла или на точку, где данные перестают повторяться.

Смещение `06400000` в шестнадцатеричном формате эквивалентно `104,857,600` в десятичном формате, что соответствует `100` мегабайтам `(100 * 1,048,576 байт)`. Это подтверждает, что файл `/tmp/disk.img` имеет размер `100` мегабайт и заполнен нулями, как и ожидалось.

## 4. Каталог `/dev`

`/dev/sda` — это устройство в системе Unix/Linux, представляющее собой первый физический или виртуальный диск, обнаруженный системой.


`/dev`: Это каталог в файловой системе Unix/Linux, который содержит специальные файлы, представляющие устройства оборудования.

`sda`: Это имя устройства, которое обычно используется для обозначения первого диска, обнаруженного системой. Буква `a` указывает на первый диск, а буквы `b`, `c`, `d` и `т.д`. могут использоваться для последующих дисков (например, `/dev/sdb`, `/dev/sdc` и т.д.).

Файл `/dev/sda` представляет собой весь диск, включая все его разделы. Например, если диск разбит на разделы, то они будут представлены как `/dev/sda1`, /`dev/sda2` и т.д., где число после `sda` указывает на номер раздела.

Примеры использования:

`/dev/sda`: Весь диск.

`/dev/sda1`: Первый раздел на диске.

`/dev/sda2`: Второй раздел на диске.

Эти устройства могут быть использованы для различных операций, таких как форматирование, монтирование, создание образов и т.д. Например, чтобы смонтировать первый раздел диска `/dev/sda` в каталог `/mnt`, можно использовать команду:

```bash
sudo mount /dev/sda1 /mnt
```
Или чтобы создать файловую систему на первом разделе диска `/dev/sda`, можно использовать команду:

```bash
sudo mkfs.ext4 /dev/sda1
```

## 5. Команда `dmesg`

Команда `dmesg` используется в Unix/Linux для вывода сообщений ядра, которые содержат информацию о событиях, происходящих в системе. Эти сообщения включают информацию о загрузке системы, обнаружении оборудования, ошибках, предупреждениях и других важных событиях.

Вот несколько ключевых моментов о команде `dmesg`:

`Вывод сообщений ядра`: Команда `dmesg` выводит все сообщения ядра, которые были записаны с момента загрузки системы. Эти сообщения могут быть полезны для диагностики проблем и понимания того, что происходит в системе.

`Фильтрация и поиск`: Вывод dmesg можно фильтровать и искать с помощью различных утилит, таких как `grep`. Например, чтобы найти все сообщения, связанные с USB-устройствами, можно использовать команду:

```bash
dmesg | grep usb
```

`Логирование`: Сообщения, выводимые командой `dmesg`, также могут быть сохранены в системных журналах, таких как `/var/log/kern.log` или `/var/log/messages`, в зависимости от конфигурации системы.

Пример вывода команды `dmesg` может выглядеть так:

```
[    0.000000] Linux version 5.4.0-54-generic (buildd@lgw01-amd64-039) (gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)) #60-Ubuntu SMP Mon Jan 18 17:22:52 UTC 2021 (Ubuntu 5.4.0-54.60-generic 5.4.65)
[    0.000000] Command line: BOOT_IMAGE=/boot/vmlinuz-5.4.0-54-generic root=UUID=12345678-1234-1234-1234-123456789abc ro quiet splash vt.handoff=7
[    0.000000] KERNEL supported cpus:
[    0.000000]   Intel GenuineIntel
[    0.000000]   AMD AuthenticAMD
[    0.000000]   Hygon HygonGenuine
[    0.000000]   Centaur CentaurHauls
[    0.000000]   zhaoxin   Shanghai
...
```

## 6. Файл журнала ядра `/var/log/kern.log.2.gz`

```bash
zless /var/log/kern.log.2.gz
```

Команда `zless /var/log/kern.log.2.gz` используется для просмотра содержимого сжатого файла `/var/log/kern.log.2.gz` с возможностью прокрутки и поиска, как если бы это был обычный текстовый файл.

Вот что делает эта команда:

`zless`: Это утилита, которая позволяет просматривать содержимое сжатых файлов (например, файлов с расширением `.gz`) с использованием интерфейса, аналогичного утилите `less`. Она автоматически разархивирует файл и позволяет вам просматривать его содержимое.

`/var/log/kern.log.2.gz`: Это путь к сжатому файлу, который вы хотите просмотреть. В данном случае, это сжатый файл журнала ядра.

## 7. Файл, генерирующий случайные данные `/dev/urandom`

```bash
sudo dd if=/dev/urandom of=/var/log/kern.log.2.gz bs=1K count=10
```

`if=/dev/urandom`: Указывает входной файл. `/dev/urandom` — это специальный файл, который генерирует случайные данные.

`of=/var/log/kern.log.2.gz`: Указывает выходной файл. В данном случае, это файл `/var/log/kern.log.2.gz`.

`bs=1K`: Устанавливает размер блока для копирования. `1K` означает 1 килобайт (1,024 байта).

`count=10`: Указывает количество блоков, которые нужно скопировать. В данном случае, это `10 блоков` по `1 килобайту` каждый.

Таким образом, команда записывает `10 килобайт` случайных данных из `/dev/urandom` в файл `/var/log/kern.log.2.gz`.

### Замечание:

Команда перезаписывает содержимое файла `/var/log/kern.log.2.gz`. Если этот файл содержит важные данные, они будут утеряны.

### Пример вывода:
После выполнения команды вы можете увидеть что-то вроде этого:


```
10+0 records in
10+0 records out
10240 bytes (10 kB, 10 KiB) copied, 0.0012345 s, 8.3 MB/s
```
Этот вывод показывает, что `10 блоков` по `1 килобайту` каждый (всего 10 килобайт) были успешно записаны в файл `/var/log/kern.log.2.gz`.

### Вывод содержимого `/dev/urandom`:

```bash
sudo dd if=/dev/urandom bs=1 count=13 | base64
```

### Пример вывода:

```
13+0 записей получено
13+0 записей отправлено
13 байт скопировано, 5,0424e-05 s, 258 kB/s
0igyUPsw+hS9ylmdKA==
```

`base64`: Утилита, которая кодирует данные в формат Base64

`0igyUPsw+hS9ylmdKA==`: Это строка, представляющая 13 байт случайных данных, закодированных в формате Base64.

## 8. loopback устройства в Unix

```bash
sudo losetup --find --show /tmp/disk.img
```

`losetup`: Это утилита Unix, которая используется для управления устройствами `loopback`. Устройства `loopback` позволяют работать с файлами как с блочными устройствами (например, с дисками).

`--find`: Этот флаг указывает losetup найти первое свободное устройство loopback.

`--show`: Этот флаг указывает losetup отобразить имя устройства `loopback`, которое было создано.

`/tmp/disk.img`: Это путь к файлу, который будет использоваться как устройство loopback.

Таким образом, команда `sudo losetup --find --show /tmp/disk.img` выполняет следующие действия:

Находит первое свободное устройство `loopback`.

Привязывает файл `/tmp/disk.img` к этому устройству `loopback`.

Отображает имя устройства `loopback`, которое было создано.

### Пример вывода:

```
/dev/loop0
```

Этот вывод указывает, что файл `/tmp/disk.img` был привязан к устройству `loopback` `/dev/loop0`.

### Применение:
После выполнения этой команды вы можете работать с файлом `/tmp/disk.img` как с обычным блочным устройством. Например, вы можете создать файловую систему на этом устройстве, смонтировать его и т.д.

### Пример создания файловой системы и монтирования:

```bash
sudo mkfs.ext4 /dev/loop0
```

```bash
sudo mount /dev/loop0 /mnt
```

### Отключение устройства `loopback`:
Когда вы закончите работу с устройством `loopback`, вы можете отключить его с помощью команды `losetup -d`:

```bash
sudo losetup -d /dev/loop0
```

Эта команда отключает устройство `loopback` `/dev/loop0` и освобождает его для дальнейшего использования.

## 9. Команда `partprobe`

```bash
sudo partprobe --summary /dev/loop0
```

## 10. Команда `dumpe2fs`

```bash
sudo dumpe2fs /dev/loop0p1
```

## 11. `/dev/disk/by-uuid`

```bash
ls -la /dev/disk/by-uuid/
```

# Практическое занятие 3

Создаем первый раздел
```bash
sudo dd if=/dev/zero of=/tmp/d1 bs=40M count=1
```
Создаем второй раздел
```bash
sudo dd if=/dev/zero of=/tmp/d2 bs=40M count=1
```
Создаем блочное устройство и получаем его имя
```bash
sudo losetup --show --find /tmp/d1
```
И второе блочное устройство
```bash
sudo losetup --show --find /tmp/d2
```
Скачиваем пакет
```bash
sudo apt install lvm2
```
Создаем физический том (PV) на loopback устройстве /dev/loop4
```bash
sudo pvcreate /dev/loop4
```
Создаем физический том (PV) на loopback устройстве /dev/loop24
```bash
sudo pvcreate /dev/loop24
```
Смотрим наличие созданных физических томов
```bash
sudo pvscan 
```
Смотрим более подробную информацию о созданных томах
```bash
sudo pvdisplay
```
Вывод:
```"/dev/loop4" is a new physical volume of "40,00 MiB"
  --- NEW Physical volume ---
  PV Name               /dev/loop4                                          - имя физического тома
  VG Name                                                                   - имя группы томов, к которой принадлежит созданный
  PV Size               40,00 MiB                                           - общий размер физического тома
  Allocatable           NO                                                  - индикатор возможности выделения пространства на томе
  PE Size               0                                                   - размер физического экстента
  Total PE              0                                                   - общее количесвто физических экстентов на данном томе
  Free PE               0                                                   - количество свободных физических экстентов на этом физическом томе
  Allocated PE          0                                                   - количество выделенных физических экстентов на этом физическом томе
  PV UUID               odG2Xw-E4bc-zeIb-xn9h-VOaQ-Nu2F-ZaBMY1              - уникальный идентификатор (UUID) физического тома
   
  "/dev/loop24" is a new physical volume of "40,00 MiB"
  --- NEW Physical volume ---
  PV Name               /dev/loop24
  VG Name               
  PV Size               40,00 MiB
  Allocatable           NO
  PE Size               0                                                                           -//-
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               AxJl2k-o3Er-tLde-W1wr-bIxq-0WOo-TGk7M7
  ...
```

Создаем группу томов в системе управления логическими томами на физическом томе `/dev/loop23`
```bash
sudo vgcreate test_vg /dev/loop23
```
То же самое, но на /dev/loop24
```bash
sudo vgcreate test_vg /dev/loop24
```
Смотрим информацию о созданной группе томов
```bash
sudo vgdisplay
```
Вывод:
```bash
--- Volume group ---
  VG Name               test_vg                                     - имя группы томов
  System ID                                                         - идентификатор системы (обычно пустой)
  Format                lvm2                                        - формат метаданных LVM
  Metadata Areas        1                                           - количество областей метаданных
  Metadata Sequence No  1                                           - номер последовательности метаданных
  VG Access             read/write                                  - доступ к группе томов. В данном случае это read/write, что означает, что группа томов доступна для чтения и записи
  VG Status             resizable                                   - статус группы томов. В данном случае это resizable, что означает, что размер группы томов можно изменять
  MAX LV                0                                           - максимальное количество логических томов (LV), которое может быть создано в этой группе томов
  Cur LV                0                                           - текущее количество логических томов в этой группе томов
  Open LV               0                                           - количество открытых логических томов
  Max PV                0                                           - максимальное количество физических томов (PV), которое может быть добавлено в эту группу томов
  Cur PV                1                                           - текущее количество физических томов в этой группе томов
  Act PV                1                                           - количество активных физических томов
  VG Size               36,00 MiB                                   - общий размер группы томов
  PE Size               4,00 MiB                                    - размер физического экстента (PE)
  Total PE              9                                           - общее количество физических экстентов в группе томов
  Alloc PE / Size       0 / 0                                       - количество выделенных физических экстентов и их размер
  Free  PE / Size       9 / 36,00 MiB                               - количество свободных физических экстентов и их размер
  VG UUID               TrC81c-AfPl-0ocp-sxrc-Xsju-Iea4-fy5mhd      - уникальный идентификатор (UUID) группы томов

```
## Форматы метаданных LVM:
### `LVM1`

#### Описание: 
`LVM1` является более старым форматом метаданных. Он использует фиксированный размер метаданных и имеет ограничения по размеру и количеству физических и логических томов.
#### Ограничения:
Максимальный размер физического тома (PV): `2 TB`.

Максимальное количество физических томов в группе томов (VG): `64`.

Максимальное количество логических томов (LV) в группе томов: `256`.

#### Совместимость: 
`LVM1` менее гибкий и имеет меньше возможностей по сравнению с `LVM2`. Он используется реже в современных системах.

### `LVM2`

#### Описание: 
`LVM2` является более современным и гибким форматом метаданных. Он использует динамический размер метаданных и поддерживает большие размеры и количество физических и логических томов.

#### Ограничения:
Максимальный размер физического тома (PV): `16 EB` (эксабайт).

Максимальное количество физических томов в группе томов (VG): `65534`.

Максимальное количество логических томов (LV) в группе томов: `65534`.

#### Совместимость: 
`LVM2` является стандартом для большинства современных систем и предоставляет больше возможностей и гибкости по сравнению с `LVM1`.

Смотрим символические ссылки на устройства блочного уровня, идентифицируемые по их UUID
```bash
ls -la /dev/disk/by-uuid/
```
Создаем логический том с именем test_lv, который будет занимать 75% свободного пространства в группе томов test_vg
```bash
sudo lvcreate -n test_lv -l 75%FREE test_vg
```
Снова проверяем информацию о группе томов
```bash
sudo vgdisplay 
```
В выводе видим изменение полей
```
...
Cur LV                1
...


...
Alloc PE / Size       6 / 24,00 MiB
Free  PE / Size       3 / 12,00 MiB
...
```
Видим изменение количества физических экстентов и их размера, а также изменение количества логических томов.
Смотрим информацию о логических томах
```bash
sudo lvdisplay
```
Вывод:
```
--- Logical volume ---
  LV Path                /dev/test_vg/test_lv                           - путь к логическому тому
  LV Name                test_lv                                        - имя логического тома
  VG Name                test_vg                                        - имя группы томов (VG), к которой принадлежит логический том
  LV UUID                rVKjfg-xvXy-w0lW-vi7W-CH7l-98rm-8snLfz         - уникальный идентификатор (UUID) логического тома
  LV Write Access        read/write                                     - доступ к логическому тому
  LV Creation host, time user-hostname, 2024-10-03 17:42:01 +0300       - хост и время создания логического тома
  LV Status              available                                      - статус логического тома. В данном случае это available, что означает, что логический том доступен для использования
  # open                 0                                              - количество открытых логических томов
  LV Size                24,00 MiB                                      - размер логического тома
  Current LE             6                                              - текущее количество логических экстентов (LE)
  Segments               1                                              - количество сегментов, из которых состоит логический том
  Allocation             inherit                                        - наследование параметров распределения. В данном случае это inherit, что означает, что параметры распределения наследуются от группы томов
  Read ahead sectors     auto                                           - количество секторов для предварительного чтения
  - currently set to     256                                            - текущее значение предварительного чтения (256 секторов)
  Block device           252:0                                          - устройство блочного уровня *
```
## * 
Устройство блочного уровня, указанное как `252:0`, представляет собой идентификатор устройства в системе Linux. Этот идентификатор состоит из двух частей: основного номера (major number) и вторичного номера (minor number). В данном случае `252` — это основной номер, а `0` — это вторичный номер.

Основной номер `(Major Number)`
Основной номер указывает на тип устройства. В системе Linux основные номера используются для идентификации драйверов устройств. Например, основной номер `252` обычно используется для устройств `LVM` (Logical Volume Manager).

Вторичный номер `(Minor Number)`
Вторичный номер указывает на конкретное устройство внутри типа устройства, определенного основным номером. В данном случае 0 указывает на первое устройство этого типа.

Что это означает?
`252:0` указывает на первое устройство `LVM` в системе.
Основной номер `252` указывает на то, что это устройство `LVM`.
Вторичный номер `0` указывает на то, что это первое устройство `LVM` в системе.

Смотрим информацию о томах разными способами
```bash
ls -la /dev/test_vg/test_lv
```
```bash
ls -la /dev/disk/by-uuid/
```
Создаем файловую систему `ext4` на логическом томе `test_lv` в группе томов `test_vg`
```bash
sudo mkfs.ext4 /dev/test_vg/test_lv 
```
Смотрим изменения после создания системы
```bash
ls -la /dev/disk/by-uuid/
```
Вывод:
```
итого 0
drwxr-xr-x 2 root root 100 окт  3 18:20 .
drwxr-xr-x 7 root root 140 окт  3 17:09 ..
lrwxrwxrwx 1 root root  10 окт  3 18:20 077e8f60-4dad-493a-aead-03dd6759d8e1 -> ../../dm-0
lrwxrwxrwx 1 root root  10 окт  3 17:09 2ba55abf-86b2-4529-84a4-7b5209f0d168 -> ../../sda3
lrwxrwxrwx 1 root root  10 окт  3 17:09 9722-12EE -> ../../sda2
```
Смотрим символические ссылки на устройства блочного уровня, идентифицируемые по их уникальным идентификаторам разделов (PARTUUID)
```bash
ls -la /dev/disk/by-partuuid/
```
Смотрим подробную информацию о нашей созданной файловой системе `ext4`
```bash
sudo dumpe2fs /dev/test_vg/test_lv
```
Вывод:
```
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem volume name:   <none>                                    - имя тома файловой системы
Last mounted on:          <not available>                           - последняя точка монтирования
Filesystem UUID:          077e8f60-4dad-493a-aead-03dd6759d8e1      - уникальный идентификатор (UUID) файловой системы
Filesystem magic number:  0xEF53                                    - магическое число файловой системы, используемое для идентификации типа файловой системы
Filesystem revision #:    1 (dynamic)                               - ревизия файловой системы (в данном случае это динамическая ревизия 1)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
                                                                    - функции файловой системы, такие как наличие журнала, расширенные атрибуты, изменение размера inode, индекс директорий и т.д
Filesystem flags:         signed_directory_hash                     - флаги файловой системы (подписанный хеш директории)
Default mount options:    user_xattr acl                            - опции монтирования по умолчанию (расширенные атрибуты пользователя и списки контроля доступа (ACL))
Filesystem state:         clean                                     - состояние файловой системы
Errors behavior:          Continue                                  - поведение при ошибках
Filesystem OS type:       Linux                                     - тип операционной системы файловой системы
Inode count:              6144                                      - количество inode в файловой системе
Block count:              6144                                      - количество блоков в файловой системе
Reserved block count:     307                                       - количество зарезервированных блоков
Overhead clusters:        1414                                      - количество кластеров накладных расходов
Free blocks:              4724                                      - количество свободных блоков
Free inodes:              6133                                      - количество свободных inode
First block:              0                                         - первый блок файловой системы
Block size:               4096                                      - размер блока файловой системы
Fragment size:            4096                                      - размер фрагмента файловой системы
Group descriptor size:    64                                        - размер дескриптора группы
Reserved GDT blocks:      2                                         - количество зарезервированных блоков GDT ???
Blocks per group:         32768                                     - количество блоков на группу
Fragments per group:      32768                                     - количество фрагментов на группу
Inodes per group:         6144                                      - количество inode на группу
Inode blocks per group:   384                                       - количество блоков inode на группу
Flex block group size:    16                                        - размер гибкой группы блоков ???
Filesystem created:       Thu Oct  3 18:20:39 2024                  - дата и время создания файловой системы
Last mount time:          n/a                                       - последнее время монтирования
Last write time:          Thu Oct  3 18:20:39 2024                  - последнее время записи
Mount count:              0                                         - количество монтирований
Maximum mount count:      -1                                        - максимальное количество монтирований (-1, неограниченное количество монтирований)
Last checked:             Thu Oct  3 18:20:39 2024                  - последняя проверка файловой системы
Check interval:           0 (<none>)                                - интервал проверки (отсутствует)
Lifetime writes:          21 kB                                     - общий объем записанных данных за всю жизнь файловой системы
Reserved blocks uid:      0 (user root)                             - пользователь, для которого зарезервированы блоки
Reserved blocks gid:      0 (group root)                            - группа, для которой зарезервированы блоки
First inode:              11                                        - первый inode
Inode size:	          256                                           - размер inode
Required extra isize:     32                                        - требуемый дополнительный размер inode
Desired extra isize:      32                                        - желаемый дополнительный размер inode
Journal inode:            8                                         - inode журнала
Default directory hash:   half_md4                                  - хеш директории по умолчанию
Directory Hash Seed:      03522eef-cf53-4168-84e6-c865616638c2      - хеш-семя директории ???
Journal backup:           inode blocks                              - резервное копирование журнала ???
Checksum type:            crc32c                                    - тип контрольной суммы ???
Checksum:                 0x623c337e                                - контрольная сумма
Journal features:         (none)                                    - функции журнала
Total journal size:       4096k                                     - общий размер журнала
Total journal blocks:     1024                                      - общее количество блоков журнала
Max transaction length:   1024                                      - максимальная длина транзакции ???
Fast commit length:       0                                         - длина быстрого коммита ???
Journal sequence:         0x00000001                                - последовательность журнала ???
Journal start:            0                                         - начало журнала


Group 0: (Blocks 0-6143) csum 0x1749                                - группа 0: блоки 0-6143, контрольная сумма 0x1749
  Primary superblock at 0, Group descriptors at 1-1                 - основной суперблок в 0, дескрипторы группы в 1-1
  Reserved GDT blocks at 2-3                                        - зарезервированные блоки GDT в 2-3
  Block bitmap at 4 (+4), csum 0xbfd434f4                           - 
  Inode bitmap at 20 (+20), csum 0x0b7950c6
  Inode table at 36-419 (+36)
  4724 free blocks, 6133 free inodes, 2 directories, 6133 unused inodes
  Free blocks: 1420-6143
  Свободные inod'ы: 12-6144
```
Создаем директрию для монтирования
```bash
sudo mkdir /mnt/ext4
```
Монтируем файловую систему на созданную директорию
```bash
sudo mount /dev/test_vg/test_lv
```
Проверяем смонтированную систему
```bash
df -h
```
Вывод:
```
Файл.система                Размер Использовано  Дост Использовано% Cмонтировано в
tmpfs                         790M         3,9M  786M            1% /run
/dev/sda3                      98G          35G   59G           38% /
tmpfs                         3,9G          71M  3,8G            2% /dev/shm
tmpfs                         5,0M            0  5,0M            0% /run/lock
tmpfs                         3,9G            0  3,9G            0% /run/qemu
/dev/sda2                     512M         6,1M  506M            2% /boot/efi
tmpfs                         790M         128K  790M            1% /run/user/1000
/dev/mapper/test_vg-test_lv    19M          24K   17M            1% /mnt/ext4
```
Последняя строка как раз и отвечает за смонтированную систему

Переходим в смонтированную систему
```bash
cd /mnt/ext4/
```
Создаем в ней новую директорию
```bash
sudo mkdir testdir
```
Запускаем новый сеанс оболочки с правами суперпользователя 
```bash
sudo bash
```
Создаем файлик с рандомным содержимым в директории testdir под названием test.txt
```bash
cd testdir/
```
```bash
touch test.txt
```
```bash
nano test.txt
```
```bash
cd ..
```
Делаем контрольную сумму всей директории в файл csum.txt
```bash
md5sum testdir/* > csum.txt
```
Выходим из bash
```bash
exit
```
Смотрим его содержимое
```bash
cat csum.txt
```
Видим вывод:
```
d3c319c7414039a03a9295a375ca16ce  testdir/test.txt
```
Создаем третий раздел
```bash
sudo dd if=/dev/zero of=/tmp/d3 bs=40M count=1
```
Добавляем его как блочное устройство
```bash
sudo losetup --show --find /tmp/d3
```
Делаем физический раздел 
```bash
sudo pvcreate /dev/loop25
```
Добавляем его в группу физических томов test_vg
```bash
sudo vgextend test_vg /dev/loop25
```
Отмонтировываем нашу файловую систему
```bash
sudo umount /mnt/ext4
```
Увеличиваем размер логического тома test_lv в группе test_vg
```bash
sudo lvextend -l +100%FREE /dev/test_vg/test_lv
```
Проверяем нашу файловую систему
```bash
sudo e2fsck -f /dev/test_vg/test_lv
```
Расширяем файловую систему на максимально выделенное пространство, выделенное под эти диски
```bash
sudo resize2fs /dev/test_vg/test_lv
```
Монтируем систему обратно, дабы проверить корректность расширения пространства и использовать его
```bash
sudo mount /dev/test_vg/test_lv /mnt/ext4/
```
Перемещаемся в нее
```bash
cd /mnt/ext4/
```
С помощью контрольной суммы проверяем сохранность всех данных, которые были до расширения пространства
```bash
md5sum -c csum.txt
```
Видим вывод:
```
testdir/test.txt: ЦЕЛ
```
`ЦЕЛ` означает, что сохранилась целостность всех данных на диске
Создаем новый раздел и делаем из него блочное устройство
```bash
sudo dd if=/dev/zero of=/tmp/d4 bs=40M count=1
```
```bash
sudo losetup  --find --show /tmp/d4
```
Создаем физический том из нашего блочного устройства
```bash
sudo pvcreate /dev/loop26
```
Добавляем наш новый том в группу test_vg
```bash
sudo vgextend test_vg /dev/loop26
```
Можем проверить логические и физические тома
```bash
sudo lvdisplay
```
```bash
sudo vgdisplay 
```
Смотрим информацию о всех физических томах
```bash
sudo pvscan 
```
Видим вывод:
```
  PV /dev/loop23   VG test_vg         lvm2 [36,00 MiB / 0    free]
  PV /dev/loop25   VG test_vg         lvm2 [36,00 MiB / 36,00 MiB free]
  PV /dev/loop26   VG test_vg         lvm2 [36,00 MiB / 0    free]
  PV /dev/loop24                      lvm2 [40,00 MiB]
  Total: 4 [148,00 MiB] / in use: 3 [108,00 MiB] / in no VG: 1 [40,00 MiB]
```
Из вывода видно, что том loop24 пуст, переместим данные, к примеру, из loop25 в loop26
```bash
sudo pvmove /dev/loop25 /dev/loop26
```
В выводе видим:
```
/dev/loop25: Moved: 66,67%
```
## ???
Удаляем физический том loop25 из группы томов test_vg
```bash
sudo vgreduce test_vg /dev/loop25
```
Смотрим список
```bash
sudo pvscan
```
Вывод:
```
  PV /dev/loop23   VG test_vg         lvm2 [36,00 MiB / 0    free]
  PV /dev/loop26   VG test_vg         lvm2 [36,00 MiB / 0    free]
  PV /dev/loop24                      lvm2 [40,00 MiB]
  PV /dev/loop25                      lvm2 [40,00 MiB]
  Total: 4 [152,00 MiB] / in use: 2 [72,00 MiB] / in no VG: 2 [80,00 MiB]
```
Видим, что loop25 удален из группы test_vg. При этом топ loop25 увеличил размер с 36Мб до 40Мб.

## ???
Освобождение и обновление метаданных?

Смотрим нашу группу томов и видим, что количество физических томов уменьшилось с 3 до 2

Также уменьшилось количество областей метаданных 
```bash
sudo vgdisplay
```
Вывод: 
```
  VG Name               test_vg
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  9
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                1
  Open LV               1
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               72,00 MiB
  PE Size               4,00 MiB
  Total PE              18
  Alloc PE / Size       18 / 72,00 MiB
  Free  PE / Size       0 / 0   
  VG UUID               4dtrP3-Ou1E-Pfuv-ZY7Z-Xi2Y-hg0R-Q6jroK
```

## Возможные причины уменьшения Metadata Areas:
### Удаление физического тома (PV) из группы томов:

Если вы удалили физический том из группы томов с помощью команды `vgreduce`, количество областей метаданных может уменьшиться, так как метаданные, хранящиеся на этом физическом томе, больше не используются.

### Перемещение данных между физическими томами:

Если вы переместили данные между физическими томами с помощью команды `pvmove`, это может привести к изменению количества областей метаданных, особенно если данные были перемещены с физического тома, который содержал метаданные.

### Изменение конфигурации группы томов:

Некоторые операции, такие как изменение конфигурации группы томов или оптимизация метаданных, могут привести к уменьшению количества областей метаданных.

Последний раз смотрим целостность системы и убеждаемся, что все так, как и должно быть
```bash
md5sum -c csum.txt
```
Вывод:
```
testdir/test.txt: ЦЕЛ
```